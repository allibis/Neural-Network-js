class NeuralNetwork{constructor(t){this.layers=t.layers||[2,1],this.learningRate=t.learningRate||.2,this.input_labels=t.input_labels||void 0,this.output_labels=t.output_labels||void 0,this.epochs=t.epochs||1,this.batchSize=t.batchSize,this.n_layers=this.layers.length-1,this.debug=t.debug||!1,this.max_input=t.max_input,this.min_input=t.min_input,this.normalize_data=t.normalize_data||!1,t.activation?this.activation_f=t.activation:this.activation_f="relu",this.checkOptions(),this.weights=[],this.bias=[];for(let t=0;t<this.n_layers;t++){let i=math.random([this.layers[t+1],this.layers[t]],-3,3),s=math.random([this.layers[t+1]],-3,3);this.weights.push(i),this.bias.push(s)}this.lastW=this.weights.length-1}checkOptions(){this.input_labels&&this.input_labels.length!==this.layers[0]&&(console.warn("number of input layers and input labels don't match. correcting"),this.layers[0]=this.input_labels.length),this.output_labels&&this.output_labels.length!==this.layers[this.n_layers]&&(console.warn("number of output layers and output labels don't match. correcting"),this.layers[this.n_layers]=this.output_labels.length),this.activation_f instanceof Array&&(this.activation_f.length<this.n_layers&&(console.warn("too few activation functions, using only the first one"),this.activation_f=this.activation_f[0]),this.activation_f.length>this.n_layers&&(console.warn("too many activation functions, deleting the extra ones"),this.activation_f.slice(0,this.n_layers))),this.max_input&&void 0===this.min_input&&console.error("min input not provided."),void 0===this.max_input&&this.min_input&&console.error("max input not provided.")}setActivation(t){options.activation?this.activation_f=t:this.activation_f="sigmoid",this.checkOptions()}setLearningRate(t){this.learningRate=t}setOutputLabels(t){this.output_labels=t}setInputLabels(t){this.input_labels=t}getNodes(t){let i=[t];for(let t=0;t<this.n_layers-1;t++){let s=math.multiply(this.weights[t],i[t]),a=math.add(this.bias[t],s);this.activation_f instanceof Array?i.push(activation(a,this.activation_f[t])):i.push(activation(a,this.activation_f))}let s=math.multiply(this.weights[this.lastW],i[this.lastW]),a=math.add(this.bias[this.lastW],s);return i.push(a),i}calculate(t){this.normalize_data&&(t=this.normalize_inputs(t));let i=this.getNodes(t)[this.n_layers];if(this.output_labels){let t=i.indexOf(Math.max(...i));return this.output_labels[t]}return i}predict(t){let i=[];if(this.input_labels)for(let s of this.input_labels){let a=t[s];void 0!==a?i.push(a):console.error("input "+s+" missing")}else{if(t.length!=this.layers[0])return void console.error("wrong number of inputs");i=t}return this.calculate(i)}backprops(t,i){if(t.length!=this.layers[0])return void console.error("wrong number of inputs");i.length!=this.layers[this.n_layers]&&console.error("wrong number of targets");let s=this.getNodes(t),a=s[this.n_layers],e=math.subtract(a,i);this.debug&&console.log("error: "+e);let n,h=s[this.n_layers-1],l=math.multiply(this.weights[this.lastW],h),o=hadamard(e,n=this.activation_f instanceof Array?d_activation(l,this.activation_f[this.n_layers-1]):d_activation(l,this.activation_f));o=math.resize(o,[math.size(o)[0],1]);let r=math.multiply(o,transpose(h)),u=math.multiply(this.learningRate,r);this.weights[this.lastW]=math.subtract(this.weights[this.lastW],u),this.bias[this.lastW]=math.subtract(this.bias[this.lastW],math.multiply(this.learningRate,math.squeeze(o)));for(let t=1;t<this.n_layers;t++){h=s[this.lastW-t];let i,a=math.transpose(this.weights[this.lastW-t+1]);e=math.multiply(a,o),l=math.multiply(this.weights[this.lastW-t],h),o=hadamard(e,i=this.activation_f instanceof Array?d_activation(l,this.activation_f[this.lastW-t]):d_activation(l,this.activation_f)),o=math.resize(o,[o.length,1]),r=math.multiply(o,transpose(h)),u=math.multiply(this.learningRate,r),this.weights[this.lastW-t]=math.subtract(this.weights[this.lastW-t],u),this.bias[this.lastW-t]=math.subtract(this.bias[this.lastW-t],math.multiply(this.learningRate,math.resize(o,[o.length])))}}train(t){this.normalize_data&&(t=this.normalize(t)),t=data_shuffle(t);let i=this.batchSize||t.length,s=[];for(let a=0;a<this.epochs;a++){this.debug&&console.log(Math.floor(100*(1-a/this.epochs))+"%");for(let a=0;a<0+i&&0<t.length;a++){let i=[];if(this.input_labels)for(let s of this.input_labels){let e=t[a][s];void 0!==e?i.push(e):console.error("input "+s+" missing")}else if((i=t[a].inputs).length!=this.layers[0])return void console.error("wrong number of inputs");if(this.output_labels){s=[];for(let i=0;i<this.output_labels.length;i++)t[a].target==this.output_labels[i]?s.push(1):s.push(0);nn.backprops(i,s)}else nn.backprops(i,t[a].target)}}}test(t){this.normalize_data&&(t=this.normalize(t));let i,s=0,a=math.zeros(t[0].target.length),e=math.zeros(t[0].target.length);this.output_labels||(i=getAverage(t));for(let n of t){let t;t=void 0!==this.input_labels?this.predict(n):this.predict(n.inputs),this.output_labels?t!=n.target&&s++:(e=math.add(e,TSS(n.target,i)),a=math.add(a,ESS(n.target,t)))}if(this.output_labels)return 100*(1-s/t.length);{let t=math.divide(a,e);return math.subtract(1,t)}}normalize(t){let i=[];for(let s of t){const t=this.normalize_inputs(s.inputs);i.push({inputs:t,target:s.target})}return i}normalize_inputs(t){return t.map(t=>(t-this.min_input)/(this.max_input-this.min_input))}saveState(){let t={weights:this.weights,biases:this.bias,learningRate:this.learningRate,activation:this.activation_f,input_labels:this.input_labels,output_labels:this.output_labels,epochs:this.epochs,layers:this.layers,min_input:this.min_input,max_input:this.max_input,normalize_data:this.normalize_data};return this.debug&&console.log("state saved"),t}loadState(t){this.weights=t.weights,this.bias=t.biases,this.learningRate=t.learningRate,this.activation_f=t.activation,this.input_labels=t.inputs||void 0,this.output_labels=t.outputs||void 0,this.epoch=t.epochs,this.layers=t.layers,this.debug&&console.log("state loaded")}reset(){this.weights=[],this.bias=[];for(let t=0;t<this.n_layers;t++){let i=math.random([this.layers[t+1],this.layers[t]],-3,3),s=math.random([this.layers[t+1]],-3,3);this.weights.push(i),this.bias.push(s)}this.debug&&console.log("neural network reset")}}function sigmoid(t){return 1/(1+math.exp(-t))}function d_sigmoid(t){return sigmoid(t)*(1-sigmoid(t))}function ReLU(t){return t<0?0:t}function d_ReLU(t){return t<0?0:1}function softplus(t){return Math.log(1+math.exp(-t))}function d_softplus(t){return sigmoid(t)}function gaussian(t){return math.exp(-1*math.pow(t,2))}function d_gaussian(t){return-2*t*math.exp(-1*math.pow(t,2))}function softmax(t){let i=0;for(let s=0;s<math.size(t)[0];s++)i+=math.exp(math.subset(t,math.index(s)));return math.map(t,(t,s,a)=>math.exp(t)/i)}function d_softmax(t){return math.multiply(softmax(t),math.subtract(1,softmax(t)))}function activation(t,i){i=i.toLowerCase();let s=t.map((t,s,a)=>"relu"===i?ReLU(t):"softplus"===i?softplus(t):"gaussian"===i?gaussian(t):"sine"===i?Math.sin(t):"sigmoid"===i?sigmoid(t):void console.error("unknown activation function"));return"softmax"===i&&(s=d_softmax(t)),s}function d_activation(t,i){i=i.toLowerCase();let s=t.map((t,s,a)=>"relu"===i?d_ReLU(t):"softplus"===i?d_softplus(t):"gaussian"===i?d_gaussian(t):"sine"===i?Math.cos(t):"sigmoid"===i?d_sigmoid(t):void 0);return"softmax"===i&&(s=d_softmax(t)),s}function hadamard(t,i){return t.map((t,s,a)=>t*math.subset(i,math.index(s)))}function transpose(t){if(t instanceof Array){let i=[],s=t[0].length||1,a=t.length;for(let e=0;e<s;e++){let n=[];for(let i=0;i<a;i++)1==s?n.push(t[i]):n.push(t[i][e]);i.push(n)}return i}return 1==math.size(t).length?math.resize(t,[1,math.size(t)[0]]):math.transpose(t)}function data_shuffle(t){for(let i=t.length-1;i>0;i--){let s=Math.floor(Math.random()*(i+1));[t[i],t[s]]=[t[s],t[i]]}return t}function getAverage(t){let i=math.zeros(t[0].target.length);for(let s of t)i=math.add(i,s.target);return math.multiply(i,1/t.length)}function TSS(t,i){if(t instanceof math.matrix){return math.map(t,(t,s,a)=>{let e=math.subset(i,math.index(s));return math.pow(t-e,2)})}if(t instanceof Array){return t=math.matrix(t),math.map(t,(t,s,a)=>{let e=math.subset(i,math.index(s));return math.pow(t-e,2)})}return math.pow(t-i,2)}function ESS(t,i){if(i instanceof math.matrix){return math.map(i,(i,s,a)=>{let e=math.subset(t,math.index(s));return math.pow(e-i,2)})}if(i instanceof Array){return i=math.matrix(i),t=math.matrix(t),math.map(i,(i,s,a)=>{let e=math.subset(t,math.index(s));return math.pow(e-i,2)})}return math.pow(t-i,2)}