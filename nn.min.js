class NeuralNetwork{constructor(t){this.layers=t.layers||[2,1],this.learningRate=t.learningRate||.2,this.input_labels=t.input_labels||void 0,this.output_labels=t.output_labels||void 0,this.epochs=t.epochs||1,this.batchSize=t.batchSize,this.n_layers=this.layers.length-1,this.debug=t.debug||!1,t.activation?this.activation_f=t.activation:this.activation_f="relu",this.checkOptions(),this.weights=[],this.bias=[];for(let t=0;t<this.n_layers;t++){let s=math.random([this.layers[t+1],this.layers[t]],-3,3),i=math.random([this.layers[t+1]],-3,3);this.weights.push(s),this.bias.push(i)}this.lastW=this.weights.length-1}checkOptions(){this.input_labels&&this.input_labels.length!==this.layers[0]&&(console.warn("number of input layers and input labels don't match. correcting"),this.layers[0]=this.input_labels.length),this.output_labels&&this.output_labels.length!==this.layers[this.n_layers]&&(console.warn("number of output layers and output labels don't match. correcting"),this.layers[this.n_layers]=this.output_labels.length),this.activation_f instanceof Array&&(this.activation_f.length<this.n_layers&&(console.warn("too few activation functions, using only the first one"),this.activation_f=this.activation_f[0]),this.activation_f.length>this.n_layers&&(console.warn("too many activation functions, deleting the extra ones"),this.activation_f.slice(0,this.n_layers)))}setActivation(t){options.activation?this.activation_f=t:this.activation_f="sigmoid",this.checkOptions()}setLearningRate(t){this.learningRate=t}setOutputLabels(t){this.output_labels=t}setInputLabels(t){this.input_labels=t}getNodes(t){let s=[t];for(let t=0;t<this.n_layers-1;t++){let i=math.multiply(this.weights[t],s[t]),a=math.add(this.bias[t],i);this.activation_f instanceof Array?s.push(activation(a,this.activation_f[t])):s.push(activation(a,this.activation_f))}let i=math.multiply(this.weights[this.lastW],s[this.lastW]),a=math.add(this.bias[this.lastW],i);return s.push(a),s}calculate(t){let s=this.getNodes(t)[this.n_layers];if(this.output_labels){let t=s.indexOf(Math.max(...s));return this.output_labels[t]}return s}predict(t){let s=[];if(this.input_labels)for(let i of this.input_labels){let a=t[i];void 0!==a?s.push(a):console.error("input "+i+" missing")}else{if(t.length!=this.layers[0])return void console.error("wrong number of inputs");s=t}return this.calculate(s)}backprops(t,s){if(t.length!=this.layers[0])return void console.error("wrong number of inputs");s.length!=this.layers[this.n_layers]&&console.error("wrong number of targets");let i=this.getNodes(t),a=i[this.n_layers],e=math.subtract(a,s);this.debug&&console.log("error: "+e);let h,n=i[this.n_layers-1],l=math.multiply(this.weights[this.lastW],n),o=hadamard(e,h=this.activation_f instanceof Array?d_activation(l,this.activation_f[this.n_layers-1]):d_activation(l,this.activation_f));o=math.resize(o,[math.size(o)[0],1]);let r=math.multiply(o,transpose(n)),u=math.multiply(this.learningRate,r);this.weights[this.lastW]=math.subtract(this.weights[this.lastW],u),this.bias[this.lastW]=math.subtract(this.bias[this.lastW],math.multiply(this.learningRate,math.squeeze(o)));for(let t=1;t<this.n_layers;t++){n=i[this.lastW-t];let s,a=math.transpose(this.weights[this.lastW-t+1]);e=math.multiply(a,o),l=math.multiply(this.weights[this.lastW-t],n),o=hadamard(e,s=this.activation_f instanceof Array?d_activation(l,this.activation_f[this.lastW-t]):d_activation(l,this.activation_f)),o=math.resize(o,[o.length,1]),r=math.multiply(o,transpose(n)),u=math.multiply(this.learningRate,r),this.weights[this.lastW-t]=math.subtract(this.weights[this.lastW-t],u),this.bias[this.lastW-t]=math.subtract(this.bias[this.lastW-t],math.multiply(this.learningRate,math.resize(o,[o.length])))}}train(t){t=data_shuffle(t);let s=this.batchSize||t.length,i=[];for(let a=0;a<this.epochs;a++){this.debug&&console.log("epoch: #"+a);for(let a=0;a<0+s&&0<t.length;a++){let s=[];if(this.input_labels)for(let i of this.input_labels){let e=t[a][i];void 0!==e?s.push(e):console.error("input "+i+" missing")}else if((s=t[a].inputs).length!=this.layers[0])return void console.error("wrong number of inputs");if(this.output_labels){i=[];for(let s=0;s<this.output_labels.length;s++)t[a].target==this.output_labels[s]?i.push(1):i.push(0);nn.backprops(s,i)}else nn.backprops(s,t[a].target)}}}test(t){let s,i=0,a=math.zeros(t[0].target.length),e=math.zeros(t[0].target.length);this.output_labels||(s=getAverage(t));for(let h of t){let t;t=void 0!==this.input_labels?this.predict(h):this.predict(h.inputs),this.output_labels?t!=h.target&&i++:(e=math.add(e,TSS(h.target,s)),a=math.add(a,ESS(h.target,t)))}if(this.output_labels)return 100*(1-i/t.length);{let t=math.divide(a,e);return math.subtract(1,t)}}saveState(){let t={weights:this.weights,biases:this.bias,learningRate:this.learningRate,activation:this.activation_f,inputs:this.input_labels,outputs:this.output_labels,epochs:this.epochs,layers:this.layers};return this.debug&&console.log("state saved"),t}loadState(t){this.weights=t.weights,this.bias=t.biases,this.learningRate=t.learningRate,this.activation_f=t.activation,this.input_labels=t.inputs||void 0,this.output_labels=t.outputs||void 0,this.epoch=t.epochs,this.layers=t.layers,this.debug&&console.log("state loaded")}reset(){this.weights=[],this.bias=[];for(let t=0;t<this.n_layers;t++){let s=math.random([this.layers[t+1],this.layers[t]],-3,3),i=math.random([this.layers[t+1]],-3,3);this.weights.push(s),this.bias.push(i)}this.debug&&console.log("neural network reset")}}function sigmoid(t){return 1/(1+math.exp(-t))}function d_sigmoid(t){return sigmoid(t)*(1-sigmoid(t))}function ReLU(t){return t<0?0:t}function d_ReLU(t){return t<0?0:1}function softplus(t){return Math.log(1+math.exp(-t))}function d_softplus(t){return sigmoid(t)}function gaussian(t){return math.exp(-1*math.pow(t,2))}function d_gaussian(t){return-2*t*math.exp(-1*math.pow(t,2))}function softmax(t){let s=0;for(let i=0;i<math.size(t)[0];i++)s+=math.exp(math.subset(t,math.index(i)));return math.map(t,(t,i,a)=>math.exp(t)/s)}function d_softmax(t){return math.multiply(softmax(t),math.subtract(1,softmax(t)))}function activation(t,s){s=s.toLowerCase();let i=t.map((t,i,a)=>"relu"===s?ReLU(t):"softplus"===s?softplus(t):"gaussian"===s?gaussian(t):"sine"===s?Math.sin(t):"sigmoid"===s?sigmoid(t):void console.error("unknown activation function"));return"softmax"===s&&(i=d_softmax(t)),i}function d_activation(t,s){s=s.toLowerCase();let i=t.map((t,i,a)=>"relu"===s?d_ReLU(t):"softplus"===s?d_softplus(t):"gaussian"===s?d_gaussian(t):"sine"===s?Math.cos(t):"sigmoid"===s?d_sigmoid(t):void 0);return"softmax"===s&&(i=d_softmax(t)),i}function hadamard(t,s){return t.map((t,i,a)=>t*math.subset(s,math.index(i)))}function transpose(t){if(t instanceof Array){let s=[],i=t[0].length||1,a=t.length;for(let e=0;e<i;e++){let h=[];for(let s=0;s<a;s++)1==i?h.push(t[s]):h.push(t[s][e]);s.push(h)}return s}return 1==math.size(t).length?math.resize(t,[1,math.size(t)[0]]):math.transpose(t)}function data_shuffle(t){for(let s=t.length-1;s>0;s--){let i=Math.floor(Math.random()*(s+1));[t[s],t[i]]=[t[i],t[s]]}return t}function getAverage(t){let s=math.zeros(t[0].target.length);for(let i of t)s=math.add(s,i.target);return math.multiply(s,1/t.length)}function TSS(t,s){if(t instanceof math.matrix){return math.map(t,(t,i,a)=>{let e=math.subset(s,math.index(i));return math.pow(t-e,2)})}if(t instanceof Array){return t=math.matrix(t),math.map(t,(t,i,a)=>{let e=math.subset(s,math.index(i));return math.pow(t-e,2)})}return math.pow(t-s,2)}function ESS(t,s){if(s instanceof math.matrix){return math.map(s,(s,i,a)=>{let e=math.subset(t,math.index(i));return math.pow(e-s,2)})}if(s instanceof Array){return s=math.matrix(s),t=math.matrix(t),math.map(s,(s,i,a)=>{let e=math.subset(t,math.index(i));return math.pow(e-s,2)})}return math.pow(t-s,2)}